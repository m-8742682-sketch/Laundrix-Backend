/**
 * Queue Management Helper
 *
 * KEY FIXES vs original:
 * - removeUserFromQueue: atomic batch write (queue + machine.nextUserId together)
 * - addUserToQueue: Firestore transaction (race-safe, idempotency key support)
 * - setCurrentUser: batch write for status + nextUserId
 */

import { queuesRef, machinesRef, usersRef, db } from "./firebase";
import { FieldValue } from "firebase-admin/firestore";

// ─── Types ────────────────────────────────────────────────────────────────────

export interface QueueUser {
  position:     number;
  userId:       string;
  name:         string;
  avatar:       string | null;
  queueToken:   string;
  joinedAt:     string;
  lastActiveAt?: string;
}

export interface QueueDocument {
  machineId:   string;
  status:      "Active" | "Paused" | "Closed";
  lastUpdated: string;
  users:       QueueUser[];
}

// ─── User existence check ────────────────────────────────────────────────────

export async function userExists(userId: string): Promise<boolean> {
  try {
    const userDoc = await usersRef.doc(userId).get();
    return userDoc.exists;
  } catch {
    return true; // assume exists on error to avoid accidental deletion
  }
}

// ─── Get next user in queue ──────────────────────────────────────────────────

export async function getNextUser(machineId: string): Promise<QueueUser | null> {
  try {
    const snap = await queuesRef.doc(machineId).get();
    if (!snap.exists) return null;

    const users: QueueUser[] = (snap.data() as QueueDocument).users ?? [];
    if (users.length === 0) return null;

    return [...users].sort((a, b) => a.position - b.position)[0];
  } catch (err) {
    console.error(`getNextUser failed for ${machineId}:`, err);
    return null;
  }
}

// ─── Position lookup ─────────────────────────────────────────────────────────

export async function getUserPosition(
  machineId: string,
  userId: string
): Promise<number | null> {
  try {
    const snap = await queuesRef.doc(machineId).get();
    if (!snap.exists) return null;

    const user = (snap.data() as QueueDocument).users?.find(
      (u) => u.userId === userId
    );
    return user?.position ?? null;
  } catch {
    return null;
  }
}

export async function isUserInQueue(
  machineId: string,
  userId: string
): Promise<boolean> {
  return (await getUserPosition(machineId, userId)) !== null;
}

// ─── REMOVE user — ATOMIC BATCH ──────────────────────────────────────────────
//
// Previous code: two separate awaits → nextUserId could go stale if network
// drops between them.  Now both writes commit together or neither does.

export async function removeUserFromQueue(
  machineId: string,
  userId: string
): Promise<boolean> {
  try {
    const snap = await queuesRef.doc(machineId).get();
    if (!snap.exists) return false;

    const users: QueueUser[] = (snap.data() as QueueDocument).users ?? [];
    if (!users.some((u) => u.userId === userId)) return false;

    const updatedUsers = users
      .filter((u) => u.userId !== userId)
      .map((u, i) => ({ ...u, position: i + 1 }));

    const newNextUserId = updatedUsers[0]?.userId ?? null;

    // ATOMIC: both queue and machine update together
    const batch = db.batch();

    batch.update(queuesRef.doc(machineId), {
      users:       updatedUsers,
      lastUpdated: new Date().toISOString(),
    });

    batch.update(machinesRef.doc(machineId), {
      nextUserId:  newNextUserId,
      lastUpdated: FieldValue.serverTimestamp(),
    });

    await batch.commit();

    console.log(`Removed ${userId} from queue ${machineId}`);
    return true;
  } catch (err) {
    console.error(`removeUserFromQueue failed:`, err);
    return false;
  }
}

// ─── ADD user — TRANSACTION (race-safe + idempotency key) ────────────────────
//
// Previous code: read → check → write in separate steps → two concurrent
// requests could both pass the "already in queue?" check before either wrote.
// Now the check AND write happen inside a single Firestore transaction.

export async function addUserToQueue(
  machineId:       string,
  userId:          string,
  name:            string,
  avatar:          string | null,
  idempotencyKey?: string       // generated by client, prevents double-join
): Promise<QueueUser | null> {
  try {
    const exists = await userExists(userId);
    if (!exists) {
      console.warn(`Cannot add ${userId} — user does not exist`);
      return null;
    }

    const result = await db.runTransaction(
      async (tx: FirebaseFirestore.Transaction) => {
        const snap = await tx.get(queuesRef.doc(machineId));

        let users: QueueUser[] = [];

        if (snap.exists) {
          users = (snap.data() as QueueDocument).users ?? [];

          // Already in queue?
          const existing = users.find((u) => u.userId === userId);
          if (existing) return existing;

          // Duplicate via idempotency key?
          if (idempotencyKey) {
            const dup = users.find((u) => u.queueToken === idempotencyKey);
            if (dup) return dup;
          }
        }

        const newUser: QueueUser = {
          position:     users.length + 1,
          userId,
          name,
          avatar,
          queueToken:   idempotencyKey ??
            `q_${Date.now()}${Math.random().toString(36).substring(2, 7)}`,
          joinedAt:     new Date().toISOString(),
          lastActiveAt: new Date().toISOString(),
        };

        const updatedUsers = [...users, newUser];

        tx.set(
          queuesRef.doc(machineId),
          {
            machineId,
            status:      "Active",
            lastUpdated: new Date().toISOString(),
            users:       updatedUsers,
          },
          { merge: true }
        );

        // Only update nextUserId if this is the first person in queue
        if (users.length === 0) {
          tx.update(machinesRef.doc(machineId), {
            nextUserId:  userId,
            lastUpdated: FieldValue.serverTimestamp(),
          });
        }

        return newUser;
      }
    );

    console.log(`Added ${userId} to queue ${machineId} at position ${result.position}`);
    return result;
  } catch (err) {
    console.error(`addUserToQueue failed:`, err);
    return null;
  }
}

// ─── Update nextUserId ────────────────────────────────────────────────────────
//
// Kept for cases where a direct update is still needed (e.g., after cron
// cleanup).  For normal join/leave, the atomic batch handles this.

export async function updateNextUserId(machineId: string): Promise<string | null> {
  try {
    const nextUser     = await getNextUser(machineId);
    const nextUserId   = nextUser?.userId ?? null;

    await machinesRef.doc(machineId).update({
      nextUserId,
      lastUpdated: FieldValue.serverTimestamp(),
    });

    return nextUserId;
  } catch (err) {
    console.error(`updateNextUserId failed:`, err);
    return null;
  }
}

// ─── Set current user — BATCH ─────────────────────────────────────────────────

export async function setCurrentUser(
  machineId: string,
  userId:    string | null
): Promise<boolean> {
  try {
    const nextUser   = await getNextUser(machineId);
    const nextUserId = nextUser?.userId ?? null;

    const batch = db.batch();

    batch.update(machinesRef.doc(machineId), {
      currentUserId: userId,
      status:        userId ? "In Use" : "Available",
      nextUserId,
      lastUpdated:   FieldValue.serverTimestamp(),
    });

    await batch.commit();

    console.log(`setCurrentUser ${machineId}: ${userId}`);
    return true;
  } catch (err) {
    console.error(`setCurrentUser failed:`, err);
    return false;
  }
}

// ─── Simple helpers ───────────────────────────────────────────────────────────

export async function getMachine(
  machineId: string
): Promise<Record<string, any> | null> {
  try {
    const snap = await machinesRef.doc(machineId).get();
    return snap.exists ? snap.data() ?? null : null;
  } catch {
    return null;
  }
}

export async function getUser(
  userId: string
): Promise<Record<string, any> | null> {
  try {
    const snap = await usersRef.doc(userId).get();
    return snap.exists ? { id: snap.id, ...snap.data() } : null;
  } catch {
    return null;
  }
}

export async function updateUserActivity(
  machineId: string,
  userId:    string
): Promise<boolean> {
  try {
    const snap = await queuesRef.doc(machineId).get();
    if (!snap.exists) return false;

    const users: QueueUser[] = (snap.data() as QueueDocument).users ?? [];
    const updatedUsers = users.map((u) =>
      u.userId === userId
        ? { ...u, lastActiveAt: new Date().toISOString() }
        : u
    );

    await queuesRef.doc(machineId).update({
      users:       updatedUsers,
      lastUpdated: new Date().toISOString(),
    });
    return true;
  } catch {
    return false;
  }
}

// ─── Cleanup deleted user from all queues ─────────────────────────────────────

export async function cleanupDeletedUser(userId: string): Promise<void> {
  try {
    const snap    = await queuesRef.get();
    const updates = snap.docs
      .filter((d) =>
        ((d.data() as QueueDocument).users ?? []).some(
          (u) => u.userId === userId
        )
      )
      .map((d) => removeUserFromQueue(d.id, userId));

    await Promise.all(updates);
    console.log(`Cleaned up deleted user ${userId}`);
  } catch (err) {
    console.error(`cleanupDeletedUser failed:`, err);
  }
}

// ─── Cleanup all queues (remove ghost users) ──────────────────────────────────

export async function cleanupAllQueues(): Promise<
  { queueId: string; removedUsers: string[] }[]
> {
  const results: { queueId: string; removedUsers: string[] }[] = [];

  try {
    const snap = await queuesRef.get();

    for (const queueDoc of snap.docs) {
      const users: QueueUser[] =
        (queueDoc.data() as QueueDocument).users ?? [];
      if (users.length === 0) continue;

      const removedUsers: string[] = [];
      const validUsers:   QueueUser[] = [];

      for (const u of users) {
        if (await userExists(u.userId)) {
          validUsers.push(u);
        } else {
          removedUsers.push(u.userId);
        }
      }

      if (removedUsers.length > 0) {
        const reordered = validUsers.map((u, i) => ({
          ...u,
          position: i + 1,
        }));

        await queuesRef.doc(queueDoc.id).update({
          users:       reordered,
          lastUpdated: new Date().toISOString(),
        });
        await updateNextUserId(queueDoc.id);

        results.push({ queueId: queueDoc.id, removedUsers });
      }
    }
  } catch (err) {
    console.error("cleanupAllQueues failed:", err);
  }

  return results;
}
